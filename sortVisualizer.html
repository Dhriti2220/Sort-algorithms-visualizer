<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const PlayIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );

        const PauseIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );

        const RotateIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="1 4 1 10 7 10"></polyline>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
            </svg>
        );

        const SortVisualizer = () => {
            const [array, setArray] = useState([]);
            const [sorting, setSorting] = useState(false);
            const [algorithm, setAlgorithm] = useState('bubble');
            const [speed, setSpeed] = useState(50);
            const [arraySize, setArraySize] = useState(50);
            const [comparing, setComparing] = useState([]);
            const [sorted, setSorted] = useState([]);
            const sortingRef = useRef(false);
            const speedRef = useRef(50);

            useEffect(() => {
                generateArray();
            }, [arraySize]);

            useEffect(() => {
                speedRef.current = speed;
            }, [speed]);

            const generateArray = () => {
                const newArray = Array.from({ length: arraySize }, () => 
                    Math.floor(Math.random() * 400) + 20
                );
                setArray(newArray);
                setComparing([]);
                setSorted([]);
                setSorting(false);
                sortingRef.current = false;
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            const getColor = (index, value) => {
                if (sorted.includes(index)) return '#00ff88'; // Neon green
                if (comparing.includes(index)) return '#ff0080'; // Neon pink
                
                // Vibrant neon gradient from cyan to magenta
                const hue = 180 + (value / 420) * 120;
                return `hsl(${hue}, 100%, 65%)`;
            };

            const bubbleSort = async () => {
                const arr = [...array];
                const n = arr.length;
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        if (!sortingRef.current) return;
                        
                        setComparing([j, j + 1]);
                        await sleep(101 - speedRef.current);
                        
                        if (arr[j] > arr[j + 1]) {
                            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                            setArray([...arr]);
                            await sleep(101 - speedRef.current);
                        }
                    }
                    setSorted(prev => [...prev, n - i - 1]);
                }
                
                setComparing([]);
                setSorted(Array.from({ length: n }, (_, i) => i));
                setSorting(false);
                sortingRef.current = false;
            };

            const selectionSort = async () => {
                const arr = [...array];
                const n = arr.length;
                
                for (let i = 0; i < n; i++) {
                    if (!sortingRef.current) return;
                    
                    let minIdx = i;
                    for (let j = i + 1; j < n; j++) {
                        if (!sortingRef.current) return;
                        
                        setComparing([minIdx, j]);
                        await sleep(101 - speedRef.current);
                        
                        if (arr[j] < arr[minIdx]) {
                            minIdx = j;
                        }
                    }
                    
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    setArray([...arr]);
                    setSorted(prev => [...prev, i]);
                    await sleep(101 - speedRef.current);
                }
                
                setComparing([]);
                setSorting(false);
                sortingRef.current = false;
            };

            const insertionSort = async () => {
                const arr = [...array];
                const n = arr.length;
                
                setSorted([0]);
                
                for (let i = 1; i < n; i++) {
                    if (!sortingRef.current) return;
                    
                    const key = arr[i];
                    let j = i - 1;
                    
                    while (j >= 0) {
                        if (!sortingRef.current) return;
                        
                        setComparing([j, j + 1]);
                        await sleep(101 - speedRef.current);
                        
                        if (arr[j] > key) {
                            arr[j + 1] = arr[j];
                            setArray([...arr]);
                            j--;
                            await sleep(101 - speedRef.current);
                        } else {
                            break;
                        }
                    }
                    
                    arr[j + 1] = key;
                    setArray([...arr]);
                    setSorted(prev => [...prev, i]);
                    await sleep(101 - speedRef.current);
                }
                
                setComparing([]);
                setSorting(false);
                sortingRef.current = false;
            };

            const quickSort = async () => {
                const arr = [...array];
                
                const partition = async (low, high) => {
                    const pivot = arr[high];
                    let i = low - 1;
                    
                    for (let j = low; j < high; j++) {
                        if (!sortingRef.current) return -1;
                        
                        setComparing([j, high]);
                        await sleep(101 - speedRef.current);
                        
                        if (arr[j] < pivot) {
                            i++;
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            setArray([...arr]);
                            await sleep(101 - speedRef.current);
                        }
                    }
                    
                    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                    setArray([...arr]);
                    setSorted(prev => [...prev, i + 1]);
                    await sleep(101 - speedRef.current);
                    
                    return i + 1;
                };
                
                const quickSortHelper = async (low, high) => {
                    if (low < high && sortingRef.current) {
                        const pi = await partition(low, high);
                        if (pi === -1) return;
                        await quickSortHelper(low, pi - 1);
                        await quickSortHelper(pi + 1, high);
                    }
                };
                
                await quickSortHelper(0, arr.length - 1);
                setComparing([]);
                setSorted(Array.from({ length: arr.length }, (_, i) => i));
                setSorting(false);
                sortingRef.current = false;
            };

            const mergeSort = async () => {
                const arr = [...array];
                
                const merge = async (left, mid, right) => {
                    const leftArr = arr.slice(left, mid + 1);
                    const rightArr = arr.slice(mid + 1, right + 1);
                    
                    let i = 0, j = 0, k = left;
                    
                    while (i < leftArr.length && j < rightArr.length) {
                        if (!sortingRef.current) return;
                        
                        setComparing([k]);
                        await sleep(101 - speedRef.current);
                        
                        if (leftArr[i] <= rightArr[j]) {
                            arr[k] = leftArr[i];
                            i++;
                        } else {
                            arr[k] = rightArr[j];
                            j++;
                        }
                        setArray([...arr]);
                        k++;
                        await sleep(101 - speedRef.current);
                    }
                    
                    while (i < leftArr.length) {
                        if (!sortingRef.current) return;
                        arr[k] = leftArr[i];
                        setArray([...arr]);
                        i++;
                        k++;
                        await sleep(101 - speedRef.current);
                    }
                    
                    while (j < rightArr.length) {
                        if (!sortingRef.current) return;
                        arr[k] = rightArr[j];
                        setArray([...arr]);
                        j++;
                        k++;
                        await sleep(101 - speedRef.current);
                    }
                };
                
                const mergeSortHelper = async (left, right) => {
                    if (left < right && sortingRef.current) {
                        const mid = Math.floor((left + right) / 2);
                        await mergeSortHelper(left, mid);
                        await mergeSortHelper(mid + 1, right);
                        await merge(left, mid, right);
                    }
                };
                
                await mergeSortHelper(0, arr.length - 1);
                setComparing([]);
                setSorted(Array.from({ length: arr.length }, (_, i) => i));
                setSorting(false);
                sortingRef.current = false;
            };

            const startSorting = () => {
                if (sorting) {
                    setSorting(false);
                    sortingRef.current = false;
                    return;
                }
                
                setSorting(true);
                sortingRef.current = true;
                setComparing([]);
                setSorted([]);
                
                switch (algorithm) {
                    case 'bubble':
                        bubbleSort();
                        break;
                    case 'selection':
                        selectionSort();
                        break;
                    case 'insertion':
                        insertionSort();
                        break;
                    case 'quick':
                        quickSort();
                        break;
                    case 'merge':
                        mergeSort();
                        break;
                    default:
                        bubbleSort();
                }
            };

            const algorithms = [
                { value: 'bubble', name: 'Bubble Sort' },
                { value: 'selection', name: 'Selection Sort' },
                { value: 'insertion', name: 'Insertion Sort' },
                { value: 'quick', name: 'Quick Sort' },
                { value: 'merge', name: 'Merge Sort' }
            ];

            return (
                <div className="w-full h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8 flex flex-col">
                    <div className="text-center mb-6">
                        <h1 className="text-4xl font-bold text-white mb-2">
                            Sorting Algorithm Visualizer
                        </h1>
                        <p className="text-purple-300">Watch sorting algorithms come to life!</p>
                    </div>

                    <div className="bg-white/10 backdrop-blur-lg rounded-xl p-6 mb-6 shadow-2xl">
                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                            <div>
                                <label className="block text-white text-sm font-semibold mb-2">
                                    Algorithm
                                </label>
                                <select
                                    value={algorithm}
                                    onChange={(e) => setAlgorithm(e.target.value)}
                                    disabled={sorting}
                                    className="w-full px-4 py-2 rounded-lg bg-white/20 text-white border border-white/30 focus:outline-none focus:ring-2 focus:ring-purple-500 disabled:opacity-50"
                                >
                                    {algorithms.map(alg => (
                                        <option key={alg.value} value={alg.value} style={{backgroundColor: '#1e293b'}}>
                                            {alg.name}
                                        </option>
                                    ))}
                                </select>
                            </div>

                            <div>
                                <label className="block text-white text-sm font-semibold mb-2">
                                    Speed: {speed}
                                </label>
                                <input
                                    type="range"
                                    min="1"
                                    max="100"
                                    value={speed}
                                    onChange={(e) => setSpeed(Number(e.target.value))}
                                    className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer"
                                    style={{accentColor: '#a855f7'}}
                                />
                            </div>

                            <div>
                                <label className="block text-white text-sm font-semibold mb-2">
                                    Array Size: {arraySize}
                                </label>
                                <input
                                    type="range"
                                    min="10"
                                    max="100"
                                    value={arraySize}
                                    onChange={(e) => setArraySize(Number(e.target.value))}
                                    disabled={sorting}
                                    className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                    style={{accentColor: '#a855f7'}}
                                />
                            </div>

                            <div className="flex gap-2">
                                <button
                                    onClick={startSorting}
                                    className="flex-1 px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 text-white rounded-lg font-semibold hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105 flex items-center justify-center gap-2"
                                >
                                    {sorting ? <PauseIcon /> : <PlayIcon />}
                                    {sorting ? 'Stop' : 'Start'}
                                </button>
                                <button
                                    onClick={generateArray}
                                    disabled={sorting}
                                    className="px-4 py-2 bg-white/20 text-white rounded-lg font-semibold hover:bg-white/30 transition-all disabled:opacity-50 flex items-center justify-center"
                                >
                                    <RotateIcon />
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 bg-white/5 backdrop-blur-sm rounded-xl p-6 shadow-2xl flex items-end justify-center gap-px overflow-hidden">
                        {array.map((value, idx) => (
                            <div
                                key={idx}
                                style={{
                                    height: `${(value / 420) * 100}%`,
                                    width: `${100 / array.length}%`,
                                    backgroundColor: getColor(idx, value),
                                    transition: sorting ? 'height 0.1s ease, background-color 0.2s ease' : 'none',
                                }}
                                className="rounded-t shadow-lg"
                            />
                        ))}
                    </div>

                    <div className="mt-6 flex justify-center gap-8 text-sm">
                        <div className="flex items-center gap-2">
                            <div className="w-4 h-4 bg-blue-400 rounded"></div>
                            <span className="text-white">Unsorted</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <div className="w-4 h-4 bg-red-500 rounded"></div>
                            <span className="text-white">Comparing</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <div className="w-4 h-4 bg-green-500 rounded"></div>
                            <span className="text-white">Sorted</span>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<SortVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>